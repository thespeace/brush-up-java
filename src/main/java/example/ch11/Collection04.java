package example.ch11;

import java.util.ArrayList;
import java.util.Collections;

public class Collection04 {
    public static void main(String[] args) {
        /**
         *    - 배열의 장단점.
         *
         *      장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간, access time)이 짧다.
         *            배열은 연속적이기 때문에 [ 배열의 주소 * 배열 요소의 크기 * 인덱스 ]만 하면 바로 n+1 번째 요소의 주소 값을 쉽게 알 수 있기 때문이다.
         *
         *      단점1: 크기를 변경할 수 없다.
         *            크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사 해야 한다. ex) 1)더 큰 배열 생성. 2)기존의 내용 복사. 3)참조 변수 변경.
         *            크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨. ex) 보통 공간이 부족하면 *2를 하여 생성.
         *
         *      단점2: 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
         *            데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 한다. ex) 배열 중간에 있는 요소를 삭제, 추가.
         *            그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다. why? 데이터의 이동이 없기 때문에.
         *
         *
         *
         *    - 배열의 단점을 보완하기 위해 등장한 "LinkdedList".
         *      배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link). <-> 배열은 각 요소가 연속적.
         *
         *      {@code
         *          class Node {    // linkedList의 각 요소를 노드(Node)라 한다.
         *              Node next;  // 각 요소는 다음 노드의 주소를 포함하고 있다.
         *              Object obj; // 데이터.
         *          }
         *      }
         *
         *      이처럼 여러 개의 노드들을 연결해놨기 때문에 변경에 유리하다. ex) 기차  <-> 배열 ex) 하나의 긴 통.
         *
         *      데이터의 삭제 : 단 한번의 참조변경만으로 가능. <-> 배열의 경우 n번째 요소 삭제 후, 뒤의 값들을 모두 땡겨와야 하고 마지막 값을 null값을 준다음 size-- 해야 한다.
         *          ex)
         *              linkedlist의 index 1번째 노드 삭제. '주소값( 다음노드 | 데이터 )'
         *              linkedlist(0x200) : 0x200( 0x300 | 0 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *              linkedlist(0x200) : 0x200( 0x350 | 0 ) -> 삭제[0x300( 0x350 | 1 )] -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *                  0번째 다음노드 주소값을 0x350으로 변경하여 1번째 노드를 삭제 후 쉽게 다음 노드에 연결.
         *
         *      데이터의 추가 : 한번의 Node객체생성과 두 번의 참조변경만으로 가능. <-> 배열의 경우 추가된 곳 이후의 요소들을 뒤로 한칸씩 밀고 사이즈 값을 늘려줘야 한다.
         *          ex)
         *              linkedlist의 index 1번째에 노드 추가. '주소값( 다음노드 | 데이터 )'
         *              linkedlist(0x200) : 0x200( 0x300 | 0 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *              linkedlist(0x200) : 0x200( 0x500 | 0 ) -> 0x500( 0x350 | 4 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *                  1번째 노드에 추가후 1번째 노드의 다음노드 주소 값을 맞춰주고, 새로 추가된 노드 앞에 있는 노드의 다음노드 주소값을 변경하여 연결.
         */

    }
}
