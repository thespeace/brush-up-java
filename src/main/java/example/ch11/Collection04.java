package example.ch11;

import java.util.ArrayList;
import java.util.Collections;

public class Collection04 {
    public static void main(String[] args) {
        /**
         *    - 배열의 장단점.
         *
         *      장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간, access time)이 짧다.
         *            배열은 연속적이기 때문에 [ 배열의 주소 * 배열 요소의 크기 * 인덱스 ]만 하면 바로 n+1 번째 요소의 주소 값을 쉽게 알 수 있기 때문이다.
         *
         *      단점1: 크기를 변경할 수 없다.
         *            크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사 해야 한다. ex) 1)더 큰 배열 생성. 2)기존의 내용 복사. 3)참조 변수 변경.
         *            크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비되어 비효율적인 메모리를 사용하게 된다. ex) 보통 공간이 부족하면 *2를 하여 생성.
         *
         *      단점2: 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
         *            데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 한다. ex) 배열 중간에 있는 요소를 삭제, 추가.
         *            그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다. why? 데이터의 이동이 없기 때문에.
         *
         *
         *
         *    - 배열의 단점을 보완하기 위해 등장한 "LinkdedList".
         *      배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link). <-> 배열은 각 요소가 연속적.
         *
         *      {@code
         *          class Node {    // linkedList의 각 요소를 노드(Node)라 한다.
         *              Node next;  // 각 요소는 다음 노드의 주소를 포함하고 있다.
         *              Object obj; // 데이터.
         *          }
         *      }
         *
         *      이처럼 여러 개의 노드들을 연결해놨기 때문에 변경에 유리하다. ex) 기차  <-> 배열 ex) 하나의 긴 통.
         *
         *      데이터의 삭제 : 단 한번의 참조변경만으로 가능. <-> 배열의 경우 n번째 요소 삭제 후, 뒤의 값들을 모두 땡겨와야 하고 마지막 값을 null값을 준다음 size-- 해야 한다.
         *          ex)
         *              linkedlist의 index 1번째 노드 삭제. '주소값( 다음노드 | 데이터 )'
         *              linkedlist(0x200) : 0x200( 0x300 | 0 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *              linkedlist(0x200) : 0x200( 0x350 | 0 ) -> 삭제[0x300( 0x350 | 1 )] -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *                  0번째 다음노드 주소값을 0x350으로 변경하여 1번째 노드를 삭제 후 쉽게 다음 노드에 연결.
         *
         *      데이터의 추가 : 한번의 Node객체생성과 두 번의 참조변경만으로 가능. <-> 배열의 경우 추가된 곳 이후의 요소들을 뒤로 한칸씩 밀고 사이즈 값을 늘려줘야 한다.
         *          ex)
         *              linkedlist의 index 1번째에 노드 추가. '주소값( 다음노드 | 데이터 )'
         *              linkedlist(0x200) : 0x200( 0x300 | 0 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *              linkedlist(0x200) : 0x200( 0x500 | 0 ) -> 0x500( 0x350 | 4 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( null | 3 )
         *                  1번째 노드에 추가후 1번째 노드의 다음노드 주소 값을 맞춰주고, 새로 추가된 노드 앞에 있는 노드의 다음노드 주소값을 변경하여 연결.
         *
         *
         *
         *    - LinkdedList - 이중 연결 리스트.
         *      링크드 리스트(linked list) - 연결리스트.
         *          데이터가 많을수록 접근성이 떨어진다.
         *              불연속적이기 때문에 하나의 노드는 다음노드의 주소밖에 모른다. 때문에 0번째 인덱스에서 5번째 인덱스로 넘어가기 위해서는 거처가야할 요소들이 많다.
         *              그래서 연속적인 배열보다는 데이터 접근성이 나쁘다.
         *
         *      더블리 링크드 리스트(doubly linked list) - 이중 연결 리스트, 접근성 향상.. 하지만 여전히 두개 이상의 노드를 건너뛰는건 불가.
         *          {@code
         *              class Node {
         *                  Node next;     // 다음 요소의 주소값
         *                  Node previous; // 이전 요소의 주소값
         *                  Object obj;
         *              }
         *          }
         *
         *      더블리 써큘러 링크드 리스트(doubly circular linked list) - 이중 원형 연결리스트
         *          더블리 링크드 리스트에 추가로, 마지막 요소의 참조값(null)을 활용한 것.
         *          마지막 요소의 다음을 맨 앞의 요소로 연결, 맨 처음 요소의 전의 요소를 맨 끝의 요소와 연결.   ex) tv의 ch1을 감소시키면 ch999가 되듯이.
         *
         *
         *      ** 실제 자바에서는 더블리 링크드 리스트로 구현이 되어있다. **
         *
         *
         *
         *    - ArrayList VS LinkedList - 성능 비교(ms단위).
         *
         *      array(0x100)      : [ 0, 1, 2, 3, 4 ]
         *      linkedlist(0x200) :  0x200( 0x300 | 0 ) -> 0x300( 0x350 | 1 ) -> 0x350( 0x380 | 2 ) -> 0x380( 0x400 | 3 ) -> 0x400( null | 4 )
         *
         *      1) 순차적으로 데이터를 추가/삭제   : ArrayList가 더 빠르다.
         *      2) 비순차적으로 데이터를 추가/삭제 : LinkedList가 더 빠르다.
         *      3) 접근시간(access time) : ArrayList가 더 빠르다.
         *              배열의 공식 : " 인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기 "
         *
         *          1. 순차적으로 요소 추가.
         *              ArrayList  : 406
         *              LinkedList : 606
         *                  배열은 한번에 저장 공간을 만드는 반면, 링크드 리스트는 새로운 요소를 추가할 때마다 객체를 새로 만들어야 하기 때문에 조금 느리다.
         *          2. 순차적으로 요소 삭제.
         *              ArrayList  : 11
         *              LinkedList : 46
         *          3. 중간에 요소 추가.
         *              ArrayList  : 7382
         *              LinkedList : 31
         *          4. 중간에 요소 삭제.
         *              ArrayList  : 6694
         *              LinkedList : 380
         *          5. 접근시간 테스트.
         *              ArrayList  : 1
         *              LinkedList : 432
         *
         *      자료구조에서는 ArrayList는 "배열 기반의 자료 구조", LinkedList는 "연결 기반의 자료 구조"이라 한다.
         *      이 이외에도 여러가지의 컬렉션이 있고, 데이터를 잘 다루기 위해서는 어떤 식으로 저장해야하는지 어떤 구조로 저장해야 하는지를 정리해놓은 학문이 자료구조(data structure)이다.
         *      이 모든 자료구조는 배열기반과 연결기반을 가지고 다 만들어져 있습니다.
         *      그렇기 때문에 배열기반은 연속적, 연결기반은 불연속적이라는 속성을 잘 이해하는 것이 중요하다.
         */

    }
}
