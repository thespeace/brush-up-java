package example.ch11;

import java.util.*;

public class Collection12 {
    public static void main(String[] args) {
        /**
         *    - TreeSet : 범위 탐색, 정렬.
         *      TreeSet은 이진 탐색 트리(binary search tree)로 구현. 범위 탐색(from~to)과 정렬에 유리.
         *      이진 트리는 모든 노드가 최대 2개(0~2)의 하위 노드를 갖는다.
         *      각 요소(node)가 나무(tree)형태로 연결(LinkedList의 변형)
         *
         *      이진 트리(binary tree)의 구조.
         *
         *          루트(root) - 1. 부모(A) - 1. A의 자식(B)
         *                                   2. A의 자식(C)
         *                      2. 부모(D) - 1. D의 자식(E)
         *      {@code
         *          class TreeNode {
         *              TreeNode left;    // 왼쪽 자식노드
         *              Object   element; // 저장할 객체
         *              TreeNode right;   // 오른쪽 자식노드
         *          }
         *      }
         *
         *    - 이진 탐색 트리(binary search tree) : 한 노드에 최대 2개의 하위 노드를 연결할 수 있는 것, 이진 트리의 많은 종류들 중 하나.
         *      부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장.
         *      단점 : 데이터가 많아질 수록 추가,삭제에 시간이 더 걸림(비교 횟수 증가)
         *
         *    - TreeSet의 데이터 저장 과정 : boolean add(Object o)
         *
         *      예시) TreeSet에 7, 4, 9, 1, 5의 순서로 데이터를 저장하면, 아래의 과정을 거친다.
         *           (루트부터 트리를 따라 내려가며 값을 비교, 작으면 왼쪽, 크면 오른쪽에 저장)
         *           1. 7 저장.
         *           2. 4 저장, 저장되어 있는 7과 비교. (비교 횟수 1)
         *           3. 7보다 작은 숫자 4를 왼쪽에 저장.
         *           4. 9 저장, 7과 비교. (비교 횟수 1)
         *           5. 7보다 큰 수인 9를 오른쪽에 저장.
         *           6. 1 저장, root부터 비교, 7보다 작으니 왼쪽으로, 이미 저장되어 있는 4와 비교.  (비교 횟수 2)
         *           7. 4보다 작으니까 4의 왼쪽에 저장.
         *           8. 5 저장, 위와 마찬가지로 root 7과 비교 후, 이미 저장되어 있는 4와 비교.  (비교 횟수 2)
         *           9. 4보다 크니 4의 오른쪽에 저장.
         *              * 요소(node)를 저장해가면서 비교횟수는 점점 늘어나서 저장에 더 시간이 많이 걸린다. == 이진트리의 단점.
         */
    }
}
